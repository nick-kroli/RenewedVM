# C++ Virtual Machine

## Overview

With the rapid evolution of technology, virtual machines have evolved into pivotal tools with a wide range of applications. This project introduces a robust C++ Virtual Machine designed to execute assembly language programs for a simulated virtual machine. The virtual machine is composed of two essential steps, each playing a crucial role in its functionality.


## Makefile

The first step, activated by running make step1, involves compiling a set of C++ files in the Step1 directory. This creates an executable named parser. Following compilation, the program processes input files located in the ParserInputTest directory. The Makefile then transfers the generated binary output to the Step2/VMBinaryInput directory to be used as the input for the Virtual Machine.

The second step, initiated by running make step2, builds upon the results of the first step, as it depends on its successful completion. Similar to the first step, this process entails the compilation of C++ files, this time in the Step2 directory. The outcome is an executable named vm. Afterwards, the program processes binary input files located in the VMBinaryInput directory.

## Step 1 - Parser

The first step involves parsing a simple assembly language program for an artificial (virtual) machine. Statements in the language will be of the form: `opcode [operand [operand]]`. The opcode will specify what kind of statement is present, and there will be zero to two operands following it. Parsing involves getting the first set of characters from the input line, recognizing the type of statement, and then obtaining the required operands. It's a straightforward parsing process.

## Step 2 - Virtual Machine

The `.bin` file is opened for reading. First, the strings in the string buffer are read and added to the string buffer. Then, instructions are read, and objects are created to represent them. These instruction objects are derived from an abstract `Stmt` object. Once the instruction buffer is created, the program counter is set to the address of the first instruction in the buffer, and the instruction pointed to by the pc is executed until an exit instruction is encountered, terminating the program.

### Data Structures Used by Virtual Machine:
---
- **Instruction Memory**:
  - A vector of smart pointers to `Stmt` objects.
  - Each object pointed to is a concrete object that extends `Stmt`.

- **Program Counter (PC)**:
  - The location of the next instruction in the instruction memory to be executed.

- **Runtime Stack**:
  - Holds the values operated on by stack-oriented instructions (e.g., pop, push, add, div).

- **Data Memory**:
  - Contains storage for variables.
  - Expands as subroutines are entered and shrinks when exiting.

### Actions: Operations of Instructions Generated by Parser
---

- **OP_ENTER_SUBROUTINE opnd**:
  - Adds a stack frame of size `opnd` to the data memory to hold variables used by the subroutine. Increments the pc.

- **OP_START_PROGRAM opnd**:
  - Sets up storage in the data memory to hold outer scope variables. Size of stack frame given by `opnd`.

- **OP_EXIT**:
  - Exits the program, i.e., terminates execution.

- **OP_JUMP opnd**:
  - Sets the pc to the address specified by `opnd`.

- **OP_JUMPZERO opnd**:
  - Removes the top element from the runtime stack. If it's zero, sets the pc to the address specified by `opnd`, otherwise increments the pc.

- **OP_GOSUB opnd**:
  - Makes a subroutine call. Stores the address of the next statement (pc+1) in a runtime stack of return addresses. Sets the pc to the value of `opnd`.

- **OP_RETURN**:
  - Returns from a subroutine call. Sets the pc to the last return address saved by an `OP_GOSUB` instruction. Pops the current subroutine stack frame.

- **OP_PUSHSCALAR opnd**:
  - Pushes the value at the location in data memory given by `opnd` onto the runtime stack.

- **OP_PUSHARRAY opnd**:
  - Adds `opnd` to the value at the top of the runtime stack, giving a location `e` in the data memory of an array element. The element at the top of the runtime stack is discarded.

- **OP_PUSHI opnd**:
  - Pushes the value of `opnd` onto the runtime stack.

- **OP_POP**:
  - Discards the value at the top of the runtime stack.

- **OP_POP_SCALAR opnd**:
  - Removes the value at the top of the runtime stack and stores it into the data memory at location `opnd`.

- **OP_POP_ARRAY opnd**:
  - Adds `opnd` to the value at the top of the runtime stack to get a value `e`. The value at the top of the runtime stack is then discarded.

- **OP_DUP**:
  - Duplicates the value at the top of the runtime stack.

- **OP_SWAP**:
  - Swaps the top two values in the runtime stack.

- **OP_ADD**:
  - Removes the top two elements from the runtime stack, adds them, and pushes the sum back onto the stack.

- **OP_NEGATE**:
  - Negates the value at the top of the runtime stack.

- **OP_MUL**:
  - Pops the top two elements of the runtime stack, multiplies them, and pushes the result back onto the stack.

- **OP_DIV**:
  - Pops the top two elements of the runtime stack, divides them, and pushes the result back onto the stack.

- **OP_PRINTS opnd**:
  - Prints the string at location `opnd` in the string buffer to standard output.

- **OP_PRINTTOS**:
  - Pops the value at the top of the runtime stack and prints it.



